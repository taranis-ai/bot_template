# .copier.yml
_min_copier_version: "9.0"

# Jinja env tweaks (optional)
_jinja_extensions:
  - jinja2.ext.do

# Ask the same questions you had before
project_name:
  type: str
  help: Project Name

package_name:
  default: "{{ project_name.lower().replace(' ', '_').replace('-', '_') }}"
  when: false
  type: str

image_name:
  default: "taranis-{{cookiecutter.project_name.lower().replace(' ', '-').replace('_', '-')}}"
  when: false
  type: str

models:
  type: str
  default: model_a
  help: Different models used in your project (comma-separated list)

author_mail:
  type: str
  default: author@ait.ac.at
  help: Your E-Mail

description:
  type: str
  default: A short description of what the bot does
  help: Description

repo_url:
  type: str
  default: ""
  help: Github URL

init_git_repo:
  type: bool
  default: false
  help: Initialize git repo?

exclude:
  - hooks/*
  - ruff.toml
  - .pre-commit-config.yaml
  - .gitignore

# --- Tasks (replace your post_gen_project.py) ---
tasks:
  # Optionally init git & set origin
  - cmd: git init -b main
    when: "{{ init_git_repo }}"
  - cmd: >
      git remote add origin
      "{{ repo_url | replace('http://', 'git@') | replace('https://', 'git@') | replace('github.com/', 'github.com:') }}.git"
    when: "{{ init_git_repo }}"
  - cmd: python - <<'PY'
      import fileinput
      from pathlib import Path

      # Parse models from answers
      models = [m.strip().lower() for m in "{{ models }}".split(",") if m.strip()]
      if not models:
          raise SystemExit("No models provided.")

      # Helper to make ClassNames from snake
      def to_class(name: str) -> str:
          return "".join(p.capitalize() for p in name.split("_"))

      # 1) Create a specific .py file for each model
      pkg = "{{ project_name|lower|replace(' ', '_')|replace('-', '_') }}"
      for m in models:
          p = Path(pkg) / f"{m}.py"
          p.parent.mkdir(parents=True, exist_ok=True)
          p.write_text(f'''from {pkg}.config import Config
# import model libraries

class {to_class(m)}:

    # model_name
    # if using HF_MODEL_INFO=true, make sure that the model_name is equal to
    # the models base name on Huggingface
    model_name = ""

    def __init__(self):
        # instantiate model here
        self.model = None

    def predict(self):
        # add inference code here
        raise NotImplementedError("The class {to_class(m)} must implement the 'predict' method")
''')

      # 2) Append fixtures & tests
      tests_dir = Path("tests")
      conftest_path = tests_dir / "conftest.py"
      test_file_path = tests_dir / "test_function.py"

      tests_dir.mkdir(exist_ok=True)
      conftest_path.touch()
      test_file_path.touch()

      with conftest_path.open("a") as cf, test_file_path.open("a") as tf:
          cf.write("import pytest\n\n")
          for m in models:
              cls = to_class(m)
              line = f"from {pkg}.{m} import {cls}\n"
              cf.write(line)
              tf.write(line)
          cf.write("\n")
          tf.write("\n")
          for m in models:
              cls = to_class(m)
              cf.write(
                  f'@pytest.fixture(scope="session")\n'
                  f"def {m}():\n"
                  f"    yield {cls}()\n\n"
              )
              tf.write(
                  f"def test_cybersec_classification_{m}({m}: {cls}):\n"
                  f'    assert False, "Add a functional test for your {cls} model"\n'
              )

      # 3) Update config.py's MODEL line
      models_str = "[" + ", ".join(f'"{m}"' for m in models) + "]"
      default_model = models[0]
      with fileinput.input(f"./{pkg}/config.py", inplace=True) as f:
          for line in f:
              if line.lstrip().startswith("MODEL"):
                  print(f"    MODEL: Literal{models_str} = \"{default_model}\"")
              else:
                  print(line, end="")

      # 4) Update build_container.sh default model
      with fileinput.input("./build_container.sh", inplace=True) as f:
          for line in f:
              if line.startswith("MODEL"):
                  print(f'MODEL=${{MODEL:-"{default_model}"}}')
              else:
                  print(line, end="")

      # 5) Update Containerfile ARG
      with fileinput.input("./Containerfile", inplace=True) as f:
          for line in f:
              if line.startswith("ARG MODEL"):
                  print(f"ARG MODEL={default_model}")
              else:
                  print(line, end="")

      # 6) Update GH workflow if present
      wf = Path(".github/workflows/build_and_merge.yml")
      if wf.exists():
          content = wf.read_text()
          content = content.replace("<models>", "[" + ", ".join(models) + "]")
          content = content.replace("<default_model>", default_model)
          wf.write_text(content)
    PY

